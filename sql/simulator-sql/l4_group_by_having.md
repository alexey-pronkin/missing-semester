В лекции мы познакомились с оператором GROUP BY и составили несколько базовых запросов с группировкой. Давайте на всякий случай ещё раз уточним логику, которая стоит за этой операцией:

Сначала в таблице определяются строки, в которых в указанном в GROUP BY столбце есть одинаковые значения.
Далее по этим значениям записи объединяются в группы, причём в группе может быть даже одна запись.
После этого над элементами этих групп, как правило, проводятся какие-то операции с помощью агрегирующих функций: например, с помощью SUM() вычисляется сумма значений в каком-либо столбце в каждой группе:

```sql
SELECT column_1, SUM(column_2)
FROM table
GROUP BY column_1
```

4. Затем в результирующий запрос попадает по одной уникальной записи из столбца, по которому осуществлялась группировка. При этом напротив каждого такого значения отражается результат агрегации по соответствующей группе, если агрегация проводилась.

Здесь важно сделать несколько уточнений.

Во-первых, группировка всегда выполняется после фильтрации, т.е. сначала выполняются инструкции в WHERE и только потом данные группируются через GROUP BY.

Во-вторых, к образовавшимся в результате применения GROUP BY группам можно применять сразу несколько агрегирующих функций (в том числе к разным колонкам).

В-третьих, группировку можно делать сразу по новым полям, посчитанным в SELECT: При этом допускается использование в GROUP BY алиаса колонки, указанного в SELECT. Следующие два запроса дадут одинаковый результат:

```sql
SELECT DATE(column_1) AS date, SUM(column_2)
FROM table
GROUP BY DATE(column_1)
```

```sql
SELECT DATE(column_1) AS date, SUM(column_2)
FROM table
GROUP BY date
```

В-четвёртых, делать агрегацию после группировки необязательно. Если не указывать агрегирующую функцию, то запрос вернёт уникальные значения в столбце, т.е. тот же результат, что и оператор DISTINCT. Можете самостоятельно запустить следующий запрос в Redash и убедиться:

```sql
SELECT user_id
FROM user_actions
GROUP BY user_id

SELECT DISTINCT user_id
FROM user_actions
```

Кстати, вопрос о том, какими способами можно отобрать уникальные значения, опытные аналитики любят задавать на собеседованиях своим менее опытным коллегам.

И наконец, последнее важное уточнение: при использовании группировки колонки, указанные в SELECT, должны находиться и в GROUP BY, если они не используются в агрегационных функциях. Это обязательное условие, и если оно не будет выполнено, то база данных вернёт ошибку.

Следующий запрос работать не будет, так как в GROUP BY указаны не все неагрегированные колонки из блока SELECT:

```sql
SELECT column_1, column_2, SUM(column_3)
FROM table
GROUP BY column_1
```

В то же время такой запрос сработает:

```sql
SELECT SUM(column_2)
FROM table
GROUP BY column_1
```

Обратите внимание, что в этом запросе в блоке SELECT нет колонки, указанной в GROUP BY, т.е. в обратную сторону правило не работает: если мы что-то указали в GROUP BY, то это не обязательно указывать в SELECT. Иными словами, выводить наименования групп не обязательно.

И ещё: вместо названий колонок в блоке GROUP BY можно использовать номер колонки, указанной в SELECT. Например, следующие два запроса эквивалентны:

```sql
SELECT column_1, column_2, SUM(column_3)
FROM table
GROUP BY column_1, column_2


SELECT column_1, column_2, SUM(column_3)
FROM table
GROUP BY 1, 2
```

При этом номера колонок из SELECT можно также использовать при сортировке в операторе ORDER BY. Можете сами поэкспериментировать с этим в следующих заданиях.

С теорией вроде бы разобрались, теперь приступим к практике. В прошлом уроке мы уже считали количество курьеров женского пола и использовали для этого фильтрацию. Группировка позволит нам провести расчёты сразу для двух полов.

А теперь, используя наши знания о группировке, давайте посчитаем, сколько заказов было сделано и сколько отменено в каждом отдельном месяце. В этот раз для работы с датами будем использовать не DATE_PART, а новую функцию DATE_TRUNC.

Функция DATE_TRUNC используется для усечения дат и времени, т.е. она работает почти как округление ROUND, только для типов данных TIMESTAMP и INTERVAL.

Синтаксис у неё такой же, как и у DATE_PART:

```sql
SELECT DATE_TRUNC(part, column)
```

На месте part в кавычках указывается, до какой точности следует обрезать переданное значение времени: 'year', 'month', 'day', 'hour' и т.д.

Возвращаемое значение имеет тип TIMESTAMP или INTERVAL, а все «части» исходного значения, менее значимые, чем заданная «часть», приравниваются к нулю (или единице, если это номер дня или месяца):

```sql
SELECT DATE_TRUNC('month', TIMESTAMP '2022-01-12 08:55:30')

Результат:
01/01/22 00:00

SELECT DATE_TRUNC('day', TIMESTAMP '2022-01-12 08:55:30')

Результат:
12/01/22 00:00

SELECT DATE_TRUNC('hour', TIMESTAMP '2022-01-12 08:55:30')

Результат:
12/01/22 08:00
```

На заметку:

Подробнее с функцией DATE_TRUNC можно ознакомиться здесь https://www.postgresqltutorial.com/postgresql-date-functions/postgresql-date_trunc/

Теперь давайте добавим к предыдущему запросу оператор HAVING, который рассматривали на лекции, и выполним фильтрацию уже после группировки.

Но перед этим обсудим одну важную особенность работы с HAVING: в этом блоке нельзя указывать алиасы расчётных полей из блока SELECT. Дело в том, что в соответствии с порядком выполнения запроса оператор SELECT выполняется после оператора HAVING. Поэтому агрегацию необходимо также указывать и в HAVING.

Например, такой запрос не сработает:

```sql
SELECT column_1, SUM(column_2) AS new_column
FROM table
GROUP BY column_1
HAVING new_column = 10
```

А такой сработает:

```sql
SELECT column_1, SUM(column_2) AS new_column
FROM table
GROUP BY column_1
HAVING SUM(column_2) = 10
```

А теперь попробуем решить задачу посложнее. Для неё нам снова пригодится агрегатное выражение с фильтрацией, которое мы рассматривали на прошлом уроке. Эту конструкцию можно применять не только ко всей таблице, но и отдельно к каждой группе, сформированной в результате применения оператора GROUP BY. В общем виде она будет выглядеть так:

```sql
SELECT column_1, agg_function(column_2) FILTER (WHERE [condition])
FROM table
GROUP BY column_1
```

Пример:

```sql
SELECT column_1, AVG(column_2) FILTER (WHERE column_3 > 100)
FROM table
GROUP BY column_1
```
