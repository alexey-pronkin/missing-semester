## Subquary

Subquary

```sql
SELECT price, product_id, name
FROM products
WHERE price=(SELECT MIN(price) FROM products)
```

Naming subtable

```sql
SELECT
  price
FROM
  (
    SELECT
      price,
      product_id,
      name
    FROM
      products
    WHERE
      price =(
        SELECT
          MIN(price)
        FROM
          products
      )
  ) t
```

different tables

```sql
SELECT
  courier_id
FROM
  courier_actions
WHERE
  action = 'deliver_order'
  AND order_id IN (
    SELECT
      DISTINCT order_id
    FROM
      user_actions
    WHERE
      user_id = 500
  )
```

## О порядке выполнения запросов в PostgreSQL

К текущему уроку мы уже успели познакомиться с основными операторами, которые составляют «скелет» стандартного SQL-запроса: `SELECT, FROM, WHERE, GROUP BY, HAVING, ORDER BY и LIMIT`.

Мы уже знаем, что порядок их написания в запросе следующий:

```
SELECT -- перечисление полей результирующей таблицы
FROM -- указание источника данных
WHERE -- фильтрация данных
GROUP BY -- группировка данных
HAVING -- фильтрация данных после группировки
ORDER BY -- сортировка результирующей таблицы
LIMIT -- ограничение количества выводимых записей
```

Тем не менее важно понимать, что порядок выполнения операторов в СУБД несколько отличается от порядка их написания в запросе. В упрощённом виде порядок выполнения запроса в PostgreSQL такой:

```
FROM -- указание источника данных
WHERE -- фильтрация данных
GROUP BY -- группировка данных
HAVING -- фильтрация данных после группировки
SELECT -- перечисление полей результирующей таблицы
ORDER BY -- сортировка результирующей таблицы
LIMIT -- ограничение количества выводимых записей
```

Таким образом:

Сначала с помощью FROM определяется таблица.
Затем в соответствии с указанным в WHERE условием из этой таблицы отбираются записи.
Потом выбранные данные группируются и агрегируются с помощью GROUP BY.
Далее из агрегированных записей отбираются те, которые удовлетворяют условию в HAVING.
Только после этого в соответствии с указанными в SELECT инструкциями формируется результирующая таблица — производятся все необходимые вычисления, присваиваются новые имена и т.д.
Затем результирующая таблица сортируется в соответствии с ORDER BY.
И наконец срабатывает ограничение на количество строк, указанное в LIMIT.
На самом деле это очень важная информация, которую следует держать в голове при составлении любых SQL-запросов.

Возможно, вы уже столкнулись с ошибками, когда пытались в блоке WHERE использовать фильтрацию по новым полям, рассчитанным в SELECT. Такая операция не соответствует порядку выполнения операторов, и поэтому так делать нельзя. Также вы могли попасть в ситуацию, когда при фильтрации в HAVING у вас не принимался алиас колонки, рассчитанной в SELECT. Это происходило по той же причине — PostreSQL просто ещё не знал о том, что вы присвоили колонке новое имя.

И ещё один важный совет. Обратите внимание, что фильтрацию данных по неагрегированным значениям можно делать как в блоке WHERE, так и в блоке HAVING. Внимательно посмотрите на следующие запросы:

```sql
SELECT sex, COUNT(user_id)
FROM users
WHERE sex != 'male'
GROUP BY sex
```

```sql
SELECT sex, COUNT(user_id)
FROM users
GROUP BY sex
HAVING sex != 'male'
```

Их результат будет одинаковым (можете убедиться в этом сами).

Однако делать фильтрацию по неагрегированным данным рекомендуется именно в блоке WHERE, т.е. заранее. В таком случае вы ещё до группировки убираете из расчётов ненужные вам данные и таким образом не расходуете вычислительные ресурсы на подсчёт значений, которые всё равно будут отфильтрованы вами позже.

Это важный момент, касающийся оптимизации SQL-запросов, поэтому рекомендуем вам принять во внимание информацию, представленную на этом шаге.

Итак, на лекции мы познакомились с подзапросами (вложенными запросами) и поняли, что в целом их синтаксис ничем не отличается от синтаксиса обычных запросов, которые мы составляли ранее. Иными словами, подзапрос — это всего лишь запрос внутри другого запроса.

Подзапросы могут применяться в следующих частях основного запроса:

в операторе FROM;
в операторе SELECT (если запрос возвращает один столбец с одним значением);
в операторах WHERE и HAVING (если запрос возвращает один столбец с одним или несколькими значениями).
Но давайте обо всём по порядку.

Прежде всего важно понять, что к результату выполнения подзапроса можно обращаться так же, как и к таблицам в базе данных, т.е. использовать их в блоке FROM вместо имеющихся таблиц:

```sql
SELECT column_1
FROM (
    SELECT column_1, column_2
    FROM table
) AS subquery_1
```

В рамках данного запроса сначала будет выполнен подзапрос, который отберёт колонки column_1 и column_2 из таблицы table, а затем уже из образовавшейся таблицы основной запрос выберет колонку column_1.

Важный момент: при использовании подзапроса в блоке FROM сформированной на основе подзапроса таблице необходимо присвоить какой-нибудь алиас, иначе основной запрос не сработает. В примере выше мы обозначили результат подзапроса как subquery_1.

Кроме того, уровней вложенности может быть несколько:

```sql
SELECT column_1
FROM (
    SELECT column_1, column_2
    FROM (
        SELECT column_1, column_2, column_3
        FROM table
    ) AS subquery_1
) AS subquery_2
```

В данном случае последовательность работы запроса такая: сначала будет выполнен подзапрос, возвращающий результат subquery_1, затем подзапрос, возвращающий результат subquery_2, и только потом в результате основного подзапроса попадёт колонка column_1. В результате получается что-то похожее на матрёшку, при этом к основной таблице table обращается только самый первый подзапрос subquery_1.

Приведённый пример довольно условный и на практике колонки таким образом отбирать не стоит, но общую идею он должен передавать.

Понимание того, как работают подзапросы в блоке FROM, нам особенно пригодится, когда мы будем учиться объединять разные таблицы в следующем уроке.

Решая предыдущую задачу, вы могли задаться вопросами: а что если один и тот же подзапрос будет использоваться в нескольких частях основного запроса? неужели каждый раз придётся дублировать один и тот же подзапрос? а что если к тому же уровней вложенности будет несколько? не получится ли тогда слишком сложный и громоздкий запрос, который будет сложно читать?

Для таких случаев в SQL предусмотрен оператор WITH, который позволяет создавать так называемые табличные выражения (CTE, common table expressions) — временные таблицы, существующие только для одного запроса. Их основное предназначение заключается в разбиении сложных запросов на несколько частей.

Табличные выражения создаются так:

```sql
WITH subquery_1 AS (
    SELECT column_1, column_2
    FROM table
    )

SELECT column_1
FROM subquery_1
```

Сравните запрос выше с результатом запроса из прошлого шага:

```sql
SELECT column_1
FROM (
    SELECT column_1, column_2
    FROM table
) AS subquery_1
```

Оператор WITH может содержать несколько табличных выражений, причём к указанным ранее выражениям можно обращаться в последующих выражениях:

```sql
WITH subquery_1 AS (
    SELECT column_1, column_2, column_3
    FROM table
    ),
     subquery_2 AS (
    SELECT column_1, column_2
    FROM subquery_1
    )

SELECT column_1
FROM subquery_2
```

Можете снова сравнить запрос выше с запросом из прошлого шага:

```sql
SELECT column_1
FROM (
    SELECT column_1, column_2
    FROM (
        SELECT column_1, column_2, column_3
        FROM table
    ) AS subquery_1
) AS subquery_2
```

Использовать в своих запросах оператор WITH или нет — решать вам, но в некоторых случаях он может упростить работу с кодом запроса.

На заметку:

Подробнее про WITH и табличные выражения можно почитать здесь.
