## Subquary

Subquary

```sql
SELECT price, product_id, name
FROM products
WHERE price=(SELECT MIN(price) FROM products)
```

Naming subtable

```sql
SELECT
  price
FROM
  (
    SELECT
      price,
      product_id,
      name
    FROM
      products
    WHERE
      price =(
        SELECT
          MIN(price)
        FROM
          products
      )
  ) t
```

different tables

```sql
SELECT
  courier_id
FROM
  courier_actions
WHERE
  action = 'deliver_order'
  AND order_id IN (
    SELECT
      DISTINCT order_id
    FROM
      user_actions
    WHERE
      user_id = 500
  )
```

## О порядке выполнения запросов в PostgreSQL

К текущему уроку мы уже успели познакомиться с основными операторами, которые составляют «скелет» стандартного SQL-запроса: `SELECT, FROM, WHERE, GROUP BY, HAVING, ORDER BY и LIMIT`.

Мы уже знаем, что порядок их написания в запросе следующий:

```
SELECT -- перечисление полей результирующей таблицы
FROM -- указание источника данных
WHERE -- фильтрация данных
GROUP BY -- группировка данных
HAVING -- фильтрация данных после группировки
ORDER BY -- сортировка результирующей таблицы
LIMIT -- ограничение количества выводимых записей
```

Тем не менее важно понимать, что порядок выполнения операторов в СУБД несколько отличается от порядка их написания в запросе. В упрощённом виде порядок выполнения запроса в PostgreSQL такой:

```
FROM -- указание источника данных
WHERE -- фильтрация данных
GROUP BY -- группировка данных
HAVING -- фильтрация данных после группировки
SELECT -- перечисление полей результирующей таблицы
ORDER BY -- сортировка результирующей таблицы
LIMIT -- ограничение количества выводимых записей
```

Таким образом:

Сначала с помощью FROM определяется таблица.
Затем в соответствии с указанным в WHERE условием из этой таблицы отбираются записи.
Потом выбранные данные группируются и агрегируются с помощью GROUP BY.
Далее из агрегированных записей отбираются те, которые удовлетворяют условию в HAVING.
Только после этого в соответствии с указанными в SELECT инструкциями формируется результирующая таблица — производятся все необходимые вычисления, присваиваются новые имена и т.д.
Затем результирующая таблица сортируется в соответствии с ORDER BY.
И наконец срабатывает ограничение на количество строк, указанное в LIMIT.
На самом деле это очень важная информация, которую следует держать в голове при составлении любых SQL-запросов.

Возможно, вы уже столкнулись с ошибками, когда пытались в блоке WHERE использовать фильтрацию по новым полям, рассчитанным в SELECT. Такая операция не соответствует порядку выполнения операторов, и поэтому так делать нельзя. Также вы могли попасть в ситуацию, когда при фильтрации в HAVING у вас не принимался алиас колонки, рассчитанной в SELECT. Это происходило по той же причине — PostreSQL просто ещё не знал о том, что вы присвоили колонке новое имя.

И ещё один важный совет. Обратите внимание, что фильтрацию данных по неагрегированным значениям можно делать как в блоке WHERE, так и в блоке HAVING. Внимательно посмотрите на следующие запросы:

```sql
SELECT sex, COUNT(user_id)
FROM users
WHERE sex != 'male'
GROUP BY sex
```

```sql
SELECT sex, COUNT(user_id)
FROM users
GROUP BY sex
HAVING sex != 'male'
```

Их результат будет одинаковым (можете убедиться в этом сами).

Однако делать фильтрацию по неагрегированным данным рекомендуется именно в блоке WHERE, т.е. заранее. В таком случае вы ещё до группировки убираете из расчётов ненужные вам данные и таким образом не расходуете вычислительные ресурсы на подсчёт значений, которые всё равно будут отфильтрованы вами позже.

Это важный момент, касающийся оптимизации SQL-запросов, поэтому рекомендуем вам принять во внимание информацию, представленную на этом шаге.

Итак, на лекции мы познакомились с подзапросами (вложенными запросами) и поняли, что в целом их синтаксис ничем не отличается от синтаксиса обычных запросов, которые мы составляли ранее. Иными словами, подзапрос — это всего лишь запрос внутри другого запроса.

Подзапросы могут применяться в следующих частях основного запроса:

в операторе FROM;
в операторе SELECT (если запрос возвращает один столбец с одним значением);
в операторах WHERE и HAVING (если запрос возвращает один столбец с одним или несколькими значениями).
Но давайте обо всём по порядку.

Прежде всего важно понять, что к результату выполнения подзапроса можно обращаться так же, как и к таблицам в базе данных, т.е. использовать их в блоке FROM вместо имеющихся таблиц:

```sql
SELECT column_1
FROM (
    SELECT column_1, column_2
    FROM table
) AS subquery_1
```

В рамках данного запроса сначала будет выполнен подзапрос, который отберёт колонки column_1 и column_2 из таблицы table, а затем уже из образовавшейся таблицы основной запрос выберет колонку column_1.

Важный момент: при использовании подзапроса в блоке FROM сформированной на основе подзапроса таблице необходимо присвоить какой-нибудь алиас, иначе основной запрос не сработает. В примере выше мы обозначили результат подзапроса как subquery_1.

Кроме того, уровней вложенности может быть несколько:

```sql
SELECT column_1
FROM (
    SELECT column_1, column_2
    FROM (
        SELECT column_1, column_2, column_3
        FROM table
    ) AS subquery_1
) AS subquery_2
```

В данном случае последовательность работы запроса такая: сначала будет выполнен подзапрос, возвращающий результат subquery_1, затем подзапрос, возвращающий результат subquery_2, и только потом в результате основного подзапроса попадёт колонка column_1. В результате получается что-то похожее на матрёшку, при этом к основной таблице table обращается только самый первый подзапрос subquery_1.

Приведённый пример довольно условный и на практике колонки таким образом отбирать не стоит, но общую идею он должен передавать.

Понимание того, как работают подзапросы в блоке FROM, нам особенно пригодится, когда мы будем учиться объединять разные таблицы в следующем уроке.

Решая предыдущую задачу, вы могли задаться вопросами: а что если один и тот же подзапрос будет использоваться в нескольких частях основного запроса? неужели каждый раз придётся дублировать один и тот же подзапрос? а что если к тому же уровней вложенности будет несколько? не получится ли тогда слишком сложный и громоздкий запрос, который будет сложно читать?

Для таких случаев в SQL предусмотрен оператор WITH, который позволяет создавать так называемые табличные выражения (CTE, common table expressions) — временные таблицы, существующие только для одного запроса. Их основное предназначение заключается в разбиении сложных запросов на несколько частей.

Табличные выражения создаются так:

```sql
WITH subquery_1 AS (
    SELECT column_1, column_2
    FROM table
    )

SELECT column_1
FROM subquery_1
```

Сравните запрос выше с результатом запроса из прошлого шага:

```sql
SELECT column_1
FROM (
    SELECT column_1, column_2
    FROM table
) AS subquery_1
```

Оператор WITH может содержать несколько табличных выражений, причём к указанным ранее выражениям можно обращаться в последующих выражениях:

```sql
WITH subquery_1 AS (
    SELECT column_1, column_2, column_3
    FROM table
    ),
     subquery_2 AS (
    SELECT column_1, column_2
    FROM subquery_1
    )

SELECT column_1
FROM subquery_2
```

Можете снова сравнить запрос выше с запросом из прошлого шага:

```sql
SELECT column_1
FROM (
    SELECT column_1, column_2
    FROM (
        SELECT column_1, column_2, column_3
        FROM table
    ) AS subquery_1
) AS subquery_2
```

Использовать в своих запросах оператор WITH или нет — решать вам, но в некоторых случаях он может упростить работу с кодом запроса.

На заметку:

Подробнее про WITH и табличные выражения можно почитать здесь.

Ещё одно важное направление применения подзапросов — создание более продвинутых условных выражений в операторах WHERE и HAVING. Но поскольку и в том, и в другом случае синтаксис и назначение подзапросов примерно одинаковые, в этом уроке мы будем рассматривать всё на примере подзапросов в WHERE.

В первую очередь важно понять, что подзапрос, возвращающий одно значение, может использоваться как обычное значение совместно с операторами сравнения.

Представьте, что нам нужно сравнить значения в каком-то столбце с максимальным, минимальным или средним значением в этом же столбце. Сделать это в рамках одного запроса не получится, так как агрегирующие функции нельзя использовать в блоке WHERE.

Например, следующий запрос работать не будет (база данных сообщит об ошибке):

```sql
SELECT column
FROM table
WHERE column = MAX(column)
```

В то же время такой запрос сработает, так как подзапрос выполнится первым и вернёт одно значение:

```sql
SELECT column
FROM table
WHERE column = (SELECT MAX(column) FROM table)
```

В результате выполнения такого запроса мы получим все значения в колонке column, равные максимальному значению в этой колонке.

В блоке WHERE результаты подзапросов, возвращающих одно значение, также можно использовать в арифметических операциях:

```sql
SELECT column
FROM table
WHERE column = (SELECT MAX(column) FROM table) - 100
```

В каких ещё случаях нам может пригодиться подзапрос в оператореWHERE?

Давайте представим, что нам нужно провести какие-нибудь расчёты за последние N дней — скажем, за последнюю неделю. Не будем же мы вручную отсчитывать 7 дней от последней даты в нашей таблице? Разумеется, не будем, так как последняя дата, к тому же, может со временем измениться, когда к нам поступят новые данные. Каждый раз писать новый запрос и считать дату вручную — занятие не для нас.

Для решения такой задачи мы можем сначала с помощью подзапроса вычислить последнюю дату в наших данных, а затем отложить от неё неделю.

Чтобы отложить от даты или прибавить к ней какой-то промежуток времени, можно использовать несложные арифметические операции с датами. Например, от текущей даты можно отнять какой-то промежуток INTERVAL:

```sql
SELECT NOW() - INTERVAL '1 year 2 months 1 week'
```

Результат:
10/10/21 19:32

Кстати, `NOW()` — полезная функция, которая позволяет получать текущую дату и время (в вашем случае она будет другой):

```sql
SELECT NOW()
```

Результат:
17/12/22 19:32

На заметку:

С другими примерами работы с INTERVAL и арифметическими операциями с датами можно ознакомиться здесь.

Про функцию `NOW()` можно дополнительно почитать тут.
Подзапрос, возвращающий несколько значений, может использоваться в блоке WHERE совместно с оператором IN — например, когда нам нужно проверить, совпадает ли значение в столбце с одним из значений из определённого множества, полученного в результате выполнения подзапроса:

```sql
SELECT column_1
FROM table_1
WHERE column_1 IN (SELECT column_2 FROM table_2)
```

При этом запрос выше будет равносилен запросу с табличным выражением:

```sql
WITH subquery AS (
    SELECT column_2
    FROM table_2
    )

SELECT column_1
FROM table_1
WHERE column_1 IN (SELECT * FROM subquery)
```

Обратите внимание, что при использовании в операторе WHERE табличного выражения обратиться просто к его имени нельзя — необходимо предварительно выбрать все его записи. т.е. написать подзапрос. При этом в табличном выражении должен быть всего один столбец, иначе база данных вернёт ошибку.

Кроме того, в табличном выражении можно хранить всего одно значение (например, результат агрегации) и аналогичным образом вызывать его в операторе WHERE как переменную:

```sql
WITH subquery AS (
    SELECT MAX(column_2)
    FROM table_2
    )

SELECT column_1
FROM table_1
WHERE column_1 = (SELECT * FROM subquery)
```

Давайте рассмотрим следующий пример.

Из наших данных довольно легко отобрать отменённые заказы — достаточно указать в `WHERE` нужный фильтр. Но как отобрать созданные, но неотменённые заказы? Это как раз можно сделать с помощью подзапроса или табличного выражения.

Как было отмечено в первом шаге, вложенный запрос может располагаться и после оператора `SELECT`. Однако результатом подзапроса в таком случае может быть только одно значение — например, результат применения агрегирующей функции к какой-либо колонке:

```sql
SELECT column_1, (SELECT MAX(column_1) FROM table) AS max_column_1
FROM table
```

В данном случае из таблицы table будет выбрана колонка column_1, и напротив каждого значения в этой колонке будет выведен результат выполнения вложенного запроса, т.е. максимальное значение в этой колонке. При этом давать алиас результату подзапроса не обязательно.

Также результаты подзапросов в блоке SELECT можно использовать в вычислениях:

```sql
SELECT column_1, (SELECT MAX(column_1) FROM table) - 100 AS column_2
FROM table
```
