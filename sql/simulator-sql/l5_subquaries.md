## Subquary

Subquary

```sql
SELECT price, product_id, name
FROM products
WHERE price=(SELECT MIN(price) FROM products)
```

Naming subtable

```sql
SELECT
  price
FROM
  (
    SELECT
      price,
      product_id,
      name
    FROM
      products
    WHERE
      price =(
        SELECT
          MIN(price)
        FROM
          products
      )
  ) t
```

different tables

```sql
SELECT
  courier_id
FROM
  courier_actions
WHERE
  action = 'deliver_order'
  AND order_id IN (
    SELECT
      DISTINCT order_id
    FROM
      user_actions
    WHERE
      user_id = 500
  )
```

## О порядке выполнения запросов в PostgreSQL

К текущему уроку мы уже успели познакомиться с основными операторами, которые составляют «скелет» стандартного SQL-запроса: `SELECT, FROM, WHERE, GROUP BY, HAVING, ORDER BY и LIMIT`.

Мы уже знаем, что порядок их написания в запросе следующий:

```
SELECT -- перечисление полей результирующей таблицы
FROM -- указание источника данных
WHERE -- фильтрация данных
GROUP BY -- группировка данных
HAVING -- фильтрация данных после группировки
ORDER BY -- сортировка результирующей таблицы
LIMIT -- ограничение количества выводимых записей
```

Тем не менее важно понимать, что порядок выполнения операторов в СУБД несколько отличается от порядка их написания в запросе. В упрощённом виде порядок выполнения запроса в PostgreSQL такой:

```
FROM -- указание источника данных
WHERE -- фильтрация данных
GROUP BY -- группировка данных
HAVING -- фильтрация данных после группировки
SELECT -- перечисление полей результирующей таблицы
ORDER BY -- сортировка результирующей таблицы
LIMIT -- ограничение количества выводимых записей
```

Таким образом:

Сначала с помощью FROM определяется таблица.
Затем в соответствии с указанным в WHERE условием из этой таблицы отбираются записи.
Потом выбранные данные группируются и агрегируются с помощью GROUP BY.
Далее из агрегированных записей отбираются те, которые удовлетворяют условию в HAVING.
Только после этого в соответствии с указанными в SELECT инструкциями формируется результирующая таблица — производятся все необходимые вычисления, присваиваются новые имена и т.д.
Затем результирующая таблица сортируется в соответствии с ORDER BY.
И наконец срабатывает ограничение на количество строк, указанное в LIMIT.
На самом деле это очень важная информация, которую следует держать в голове при составлении любых SQL-запросов.

Возможно, вы уже столкнулись с ошибками, когда пытались в блоке WHERE использовать фильтрацию по новым полям, рассчитанным в SELECT. Такая операция не соответствует порядку выполнения операторов, и поэтому так делать нельзя. Также вы могли попасть в ситуацию, когда при фильтрации в HAVING у вас не принимался алиас колонки, рассчитанной в SELECT. Это происходило по той же причине — PostreSQL просто ещё не знал о том, что вы присвоили колонке новое имя.

И ещё один важный совет. Обратите внимание, что фильтрацию данных по неагрегированным значениям можно делать как в блоке WHERE, так и в блоке HAVING. Внимательно посмотрите на следующие запросы:

```sql
SELECT sex, COUNT(user_id)
FROM users
WHERE sex != 'male'
GROUP BY sex
```

```sql
SELECT sex, COUNT(user_id)
FROM users
GROUP BY sex
HAVING sex != 'male'
```

Их результат будет одинаковым (можете убедиться в этом сами).

Однако делать фильтрацию по неагрегированным данным рекомендуется именно в блоке WHERE, т.е. заранее. В таком случае вы ещё до группировки убираете из расчётов ненужные вам данные и таким образом не расходуете вычислительные ресурсы на подсчёт значений, которые всё равно будут отфильтрованы вами позже.

Это важный момент, касающийся оптимизации SQL-запросов, поэтому рекомендуем вам принять во внимание информацию, представленную на этом шаге.
