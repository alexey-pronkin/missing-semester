# Lecture 1

Неправильный порядок или ошибки в ключевых словах. Правильный порядок операторов в запросе выглядит так:
SELECT -- перечисление полей результирующей таблицы
FROM -- указание источника данных
WHERE -- фильтрация данных
GROUP BY -- группировка данных
HAVING -- фильтрация данных после группировки
ORDER BY -- сортировка результирующей таблицы
LIMIT -- ограничение количества выводимых записей

```sql
SELECT * FROM courier_actions LIMIT 10
SELECT * FROM courier_actions ORDER BY courier_id LIMIT 10
```

Сортировать результат SQL-запроса можно сразу по нескольким колонкам, указывая их после ORDER BY через запятую вместе с направлением сортировки (ASC или DESC).

При этом по умолчанию сортировка происходит по возрастанию, т.е. ASC указывать не обязательно. Для сортировки по убыванию после ORDER BY необходимо явно указать DESC:

```sql
SELECT column
FROM table
ORDER BY column -- сортировка по возрастанию


SELECT column
FROM table
ORDER BY column ASC -- сортировка по возрастанию


SELECT column
FROM table
ORDER BY column DESC -- сортировка по убыванию


SELECT column_1, column_2
FROM table
ORDER BY column_1 DESC, column_2 -- сначала сортировка по первой колонке (по убыванию),
                                 -- затем по второй (по возрастанию)
```

Теперь немного поработаем с оператором LIMIT, который ограничивает число извлекаемых из таблицы записей.

Записывается он так:

```sql
SELECT column
FROM table
LIMIT n
```

На месте n может быть любое целое число — ровно столько записей, сколько вам необходимо. Если n превысит количество записей в таблице, то в результат попадут все записи.

Вот мы и разобрались, как работают операторы ORDER BY и LIMIT. Разумеется их можно совмещать в одном запросе, при этом LIMIT выполняется после оператора ORDER BY и ограничивает число записей в уже отсортированном результате.

При составлении SQL-запросов колонкам в результирующей таблице можно присваивать любые другие имена (их называют «алиасы»). Это можно делать с помощью оператора AS:

```sql
SELECT name AS new_name
FROM table
```

Если вдруг вам покажется, что на написание оператора AS уходит слишком много времени, то его можно опустить, указав новое имя колонки без него. Так тоже сработает:

```sql
SELECT name new_name
FROM table
```

Иногда возникает необходимость изменить тип данных в какой-нибудь колонке результирующей таблицы, не меняя при этом свойства исходной таблицы. Например, можно преобразовать число в текст (тип данных VARCHAR) — для этого существует оператор CAST:

```sql
SELECT CAST(numbers AS VARCHAR)
FROM table
```

Также это можно сделать с помощью специального синтаксиса:

```sql
SELECT numbers::VARCHAR
FROM table
```

На заметку:

В Redash тип данных указан справа от названия колонки. Подробнее про типы данных можно почитать [здесь](https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-data-types/).

В отдельных таблицах некоторые колонки представлены в формате даты (DATE) и времени (TIMESTAMP). Давайте немного поработаем с такими данными.

На практике бывают такие задачи, когда нужна, например, не вся дата, а какая-то её часть: год, месяц, день, час и т.д. Извлечь эту часть из исходных данных позволяет функция DATE_PART. Синтаксис следующий:

```sql
SELECT DATE_PART(part, column)
```

На месте part нужно в кавычках указать ту часть, которую необходимо извлечь: 'year', 'month', 'day', 'hour' и т.д. На месте column следует указать нужную колонку либо конкретную дату/время.

Пример:

`sql SELECT DATE_PART('day', TIMESTAMP '2022-01-12')`

Результат:
12

На заметку:

Ознакомиться с другими примерами использования функции DATE_PART можно [здесь](https://www.postgresqltutorial.com/postgresql-date-functions/postgresql-date_part/). https://www.postgresql.org/docs/8.1/functions-datetime.html

А теперь задача немного поинтереснее. Вы могли заметить, что в прошлом задании для отдельных строк функция DATE_PART не вернула год рождения курьера — вместо них образовались пустые значения (если не заметили, посмотрите внимательно на запрос из прошлого задания).

На самом деле это произошло потому, что в наших данных в колонке birth_date есть пропуски — так называемые NULL значения. Иными словами, для отдельных курьеров просто не указаны их дни рождения. Есть масса вариантов, почему так могло произойти, но у нас сейчас нет времени всё это выяснять — нам просто нужно научиться как-то обрабатывать такие случаи.

Давайте сделаем так, чтобы вместо пустых значений функция DATE_PART возвращала какое-нибудь значение. В этом нам поможет функция COALESCE, которая возвращает первое не NULL значение из списка поданных ей на вход аргументов:

```
SELECT COALESCE(NULL, 'I am not NULL' , 25)
```

Результат:
'I am not NULL'

```
SELECT COALESCE(NULL, 25, 'I am not NULL' )
```

Результат:
25

Чтобы заполнить пропуски в колонке, достаточно применить функцию COALESCE к колонке с пропусками и указать в качестве второго аргумента то значение, которое мы хотим видеть вместо NULL:

```sql
SELECT COALESCE(column, 'filler value')
FROM table
```

На заметку:

С другими примерами использования функции COALESCE можно ознакомиться [here](https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-coalesce/).

В этом задании немного поработаем с текстовыми данными и рассмотрим функцию CONCAT, с помощью которой можно соединять в одну строку значения из нескольких столбцов.

Функция CONCAT принимает на вход несколько аргументов и возвращает результат их последовательного сложения друг с другом. Хорошая аналогия — составление предложений из разных карточек со словами:

SELECT CONCAT('SQL', ' ', 'Simulator ', 2022)

Результат:
SQL Simulator 2022

При этом аргументы не обязательно должны быть выражены строками — главное, они должны быть конвертируемыми в строки.

На заметку:

Ознакомиться с другими примерами использования функции CONCAT можно [здесь](https://www.postgresqltutorial.com/postgresql-string-functions/postgresql-concat-function/).

Почитать о других функциях для работы со строками можно [тут](https://www.postgresqltutorial.com/postgresql-string-functions/).

Для работы с числовыми значениями в PostgreSQL доступны разные арифметические операторы. Ниже в таблице указаны наиболее популярные:

Оператор Описание Пример Результат

```
  - Сложение 2 + 3 5
  * Вычитание 2 - 3 -1
  - Умножение 2 \* 3 6
  / Деление 4 / 2 2
  % Остаток от деления 5 % 4 1
  ^ Возведение в степень 2 ^ 3 8
```

Пример:

Если бы мы захотели перевести 6200 рублей в доллары по курсу 1 доллар = 62 рубля, то операция выглядела бы следующим образом:

SELECT 6200 / 62

Результат:
100

На заметку:

Ознакомиться со всеми арифметическими операторами можно [здесь](https://www.postgresql.org/docs/9.3/functions-math.html).

Наряду с арифметическими операторами в PostgreSQL также доступны разные математические функции. Например, для округления вещественных чисел («чисел с плавающей точкой») можно использовать ROUND:

```
SELECT ROUND(100.5454, 2)

Результат:
100.55

SELECT ROUND(100.551, 1)

Результат:
100.6

SELECT ROUND(100.5511)

Результат:
101.0
```

Первым аргументом указывается само значение, которое хотим округлить. Вторым — число знаков после точки, до которого хотим округлить. Второй аргумент указывать не обязательно: если его не указать, произойдёт округление до целого числа (однако тип данных при этом не поменяется).

Также обратите внимание, что Redash накладывает дополнительное форматирование на выводимый результат, поэтому, например, результат второго запроса будет выглядеть так: 100.60

Настроить формат отображения можно с помощью кнопки Edit Visualization.

На заметку:

Ознакомиться с другими математическими функциями можно [здесь](https://www.postgresqltutorial.com/postgresql-math-functions/).

А что если бы мы захотели повысить цену не на все товары, а, скажем, только на дорогие? Это можно сделать с помощью условной конструкции CASE. Она имеет следующий синтаксис:

```sql
CASE
WHEN logical_expression_1 THEN expression_1
WHEN logical_expression_2 THEN expression_2
...
ELSE expression_else
END AS case_example
```

На самом деле в этой конструкции нет ничего страшного, логика работы оператора CASE довольно простая:

На каждом этапе WHEN – THEN вычисляется некоторое логическое выражение logical_expression, стоящее после WHEN. Если оно оказывается истинным (TRUE), то в качестве результата оператор возвращает выражение expression, стоящее после THEN, и заканчивает свою работу.
Если выражение оказывается ложным (FALSE), то оператор продолжает работу и проверяет следующее условие.
Если ни одно из условий не проходит проверку на истинность, то возвращается выражение, указанное после ELSE. При этом ELSE указывать не обязательно — если его не указать, то вернётся пустое значение NULL (в случае, если все проверки после WHEN оказались ложными).
В конце обязательно указывается ключевое слово END, которое говорит об окончании конструкции CASE. Также после END новому расчётному полю можно присвоить некоторое имя, но это делать не обязательно. Обязательными являются только ключевые слова CASE, WHEN, THEN и END.
Пример:

Следующая конструкция разобъёт весь список наименований на три категории: «мясо», «рыба» и «другое». Соответственно, если в первых двух условиях мы не учтём какие-то наименования из колонки name (например, «телятину»), то они попадут в категорию «другое».

```sql
SELECT CASE
       WHEN name='свинина' OR name='баранина' OR name='курица' THEN 'мясо'
       WHEN name='треска' OR name='форель' OR name='окунь' THEN 'рыба'
       ELSE 'другое'
       END AS сategory
FROM table
```

Теперь немного о логических выражениях: в SQL они могут включать операторы сравнения и логические операции.

К операторам сравнения относятся:

```
= («равно»)
<> или != («не равно»)
< («меньше»)
> («больше»)
<= («меньше или равно»)
>= («больше или равно»)
```

Результатом работы операторов сравнения могут быть три состояния:

```
TRUE («истина»)
FALSE («ложь»)
NULL («неопределённое состояние» — когда одно из сравниваемых значений NULL)
```

С этими тремя состояниями можно проводить следующие логические операции:

```
AND («И»)
OR («ИЛИ»)
NOT («НЕ»)
```

Результатом этих логических операций также могут быть три вышеуказанных логических состояния (TRUE, FALSE или NULL):

```
a	b	a AND b	a OR b
TRUE	TRUE	TRUE	TRUE
TRUE	FALSE	FALSE	TRUE
TRUE	NULL	NULL	TRUE
FALSE	FALSE	FALSE	FALSE
FALSE	NULL	FALSE	NULL
NULL	NULL	NULL	NULL
a	NOT a
TRUE	FALSE
FALSE	TRUE
NULL	NULL
```

Таким образом, операторы сравнения и логические операции позволяют писать комбинированные логические выражения.

Пример:

Допустим, нам известно, что a=10 и b=5. Тогда следующее логическое выражение вернёт TRUE:

a >= 10 OR b > 10

Также важно понимать, что существуют приоритеты выполнения операций:

```
умножение и деление (* и /)
сложение и вычитание (+ и -)
операторы сравнения (=, !=, >, <, >=, <=)
NOT
AND
OR
На порядок выполнения операторов также можно влиять с помощью скобок. Выражения, помещённые в скобки, будут иметь наивысший приоритет — всё как в математике.
```

## Подведём итоги

На этом уроке мы:

Познакомились с операторами SELECT и FROM и научились составлять базовые запросы.
Узнали, как сортировать записи с помощью оператора ORDER BY.
Научились ограничивать количество выводимых записей с помощью оператора LIMIT.
Выяснили, как преобразовывать типы данных с помощью CAST.
Научились работать с датой и временем и познакомились с функцией DATE_PART.
Узнали про NULL значения и поработали с COALESCE.
Научились работать с текстовыми данными и соединять строки с помощью функции CONCAT.
Поработали с арифметическими операторами и математическими функциями.
Познакомились с конструкцией CASE и научились составлять комплексные логические выражения.
Кажется, для первого занятия получилось весьма продуктивно. Пора двигаться дальше!
