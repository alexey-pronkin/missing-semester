На лекции мы познакомились с ключевым словом DISTINCT, которое позволяет отбирать уникальные значения в колонке, т.е. избавляться от всех дубликатов. Указывается DISTINCT сразу после SELECT:

SELECT DISTINCT column
FROM table

На заметку:

Подробнее про DISTINCT: https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-select-distinct/

Ключевое слово DISTINCT можно применять не только к одной колонке, но и сразу к нескольким:

SELECT DISTINCT column_1, column_2
FROM table

В таком случае в качестве результата запрос вернёт уникальные комбинации значений, встречающихся в колонках. Давайте это проверим.

Ну что же, с DISTINCT мы разобрались, теперь перейдём к агрегирующим функциям.

Агрегирующими функциями называют функции, которые обрабатывают определённый набор строк и возвращают одно обобщающее значение. Если вы когда-нибудь работали в Excel, то наверняка сталкивались с подсчётом суммы или максимального/минимального значения по столбцу — речь идёт именно об этом.

Вот несколько примеров таких функций в SQL:

COUNT() — считает количество значений в колонке.
SUM() — вычисляет сумму значений.
AVG() — вычисляет среднее значение.
MAX() — вычисляет максимальное значение.
MIN() — вычисляет минимальное значение.
Пример:

SELECT AVG(column)
FROM table

Обратите внимание, что некоторые из вышеуказанных функций нельзя применять к колонкам с текстом, датами и временем, так как не вполне понятно, что, например, означает найти среднее значение или сумму наименований товаров. В то же время «максимальное» наименование товара вычислить можно — функция MAX() будет искать наибольшее значение в упорядоченной последовательности символов (в данном случае — упорядоченной по алфавиту).

Впрочем, заучивать границы применимости этих функций не нужно — просто руководствуйтесь здравым смыслом.

Также при работе с функцией COUNT важно учитывать один нюанс: при подсчёте количества записей вместо наименования колонки иногда используют звёздочку «\*»:

SELECT COUNT(\*)
FROM table

Однако важно иметь в виду, что запрос со звёздочкой возвращает количество вообще всех записей, а запрос с указанием столбца — количество тех записей, где в заданном столбце значения не являются NULL.

Как вы помните, в таблице users у некоторых пользователей не были указаны их даты рождения. Попробуйте самостоятельно запустить в Redash следующие запросы и сравните результаты:

SELECT COUNT(\*)
FROM users

SELECT COUNT(birth_date)
FROM users

На заметку:

Подробнее с агрегирующим функциями можно ознакомиться здесь. https://www.postgresqltutorial.com/postgresql-aggregate-functions/

В документации PostgreSQL есть и более специфические функции, но списка выше на первое время нам точно хватит. https://www.postgresql.org/docs/9.5/functions-aggregate.html
И ещё один важный момент: агрегирующие функции можно применять в сочетании с ключевым словом DISTINCT. В таком случае расчёты будут производиться только по уникальным значениям. Если в случае с MIN() и MAX() это не имеет особого смысла, то при расчёте AVG() и SUM() иногда это бывает полезно.

Пример:

SELECT SUM(DISTINCT column)
FROM table

При этом довольно часто DISTINCT используется в сочетании с COUNT() — для подсчёта числа уникальных пользователей, уникальных заказов и т.д. Этим мы с вами и займёмся!

Над результатами агрегирующих функций можно сразу проводить арифметические операции.

В нашем случае, чтобы получить корректный результат деления, необходимо хотя бы одно из значений предварительно привести к типу DECIMAL. Иначе результатом деления целого числа на целое число будет тоже целое число.

Кстати, с подобной проблемой можно ознакомиться на stackoverflow. https://stackoverflow.com/questions/34504497/division-not-giving-my-answer-in-postgresql Это крайне полезный ресурс для поиска ответов на свои вопросы. Даже опытные программисты часто им пользуются. Можете уже сейчас начать вырабатывать привычку обращаться к нему в случае возникновения проблем.

А что если для расчётов нам нужны не все данные в столбце, а только какая-то часть? Тогда в запрос с агрегирующими функциями можно включить оператор WHERE и указать условие для отбора записей. Примерно так:

SELECT MAX(column)
FROM table
WHERE [condition]

В таком случае сначала будет выполнена фильтрация таблицы и только потом будет произведена агрегация по оставшимся записям.

Теперь решим ещё одну задачу на агрегацию с фильтрацией и заодно познакомимся с новой функцией array_length, которая вычисляет количество элементов в массиве (длину массива).

Как вы помните, в таблице orders содержимое заказов представлено в виде списков товаров. Чтобы посчитать количество товаров в заказе, можно как раз воспользоваться функцией array_length. Записывается она так:

SELECT array_length(ARRAY[1,2,3], 1)

Результат:
3

Синтаксис может показаться вам немного сложным, но это только на первый взгляд! Давайте разберёмся. ARRAY[1,2,3] — это некоторый список из трёх значений. Единица в качестве второго аргумента — это размерность массива, по которой считается его длина. Так как список у нас одноразмерный (просто список значений), то выбор у нас невелик — можем указать только первую размерность.

Если бы у нас была таблица N x N, в которой были бы и строки, и столбцы, то размерности было бы две и тогда мы могли бы указать либо первую, либо вторую размерность. Обратите внимание на разный результат вычислений:

SELECT array_length(ARRAY[[1,2], [3,4], [5,6]], 1)

Результат:
3

SELECT array_length(ARRAY[[1,2], [3,4], [5,6]], 2)

Результат:
2

В примере выше количество списков внутри основного списка — это количество строк в таблице, а количество элементов внутри каждого внутреннего списка — это количество столбцов.

Разумеется, на месте массива можно указывать имя колонки, которая содержит массивы (как в нашем случае):

SELECT array_length(column, 1)
FROM table

На заметку:

Узнать больше о функциях для работы с массивами можно в документации. https://www.postgresql.org/docs/8.4/functions-array.html С некоторыми из них мы познакомимся в следующих уроках.

В качестве аргумента агрегирующих функций могут выступать не только столбцы, но и любое арифметическое выражение или результат другой функции:

SELECT AVG(some_function(column))
FROM table

SELECT AVG(column_1 \* column_2)
FROM table

Давайте попробуем рассчитать средний возраст пользователей мужского пола. Для этого воспользуемся новой для нас функцией AGE().

Функция AGE() возвращает разницу между двумя значениями в формате TIMESTAMP. При этом из первого значения вычитается второе, а сама разница получается в формате INTERVAL:

SELECT AGE('2022-12-12', '2021-11-10')

Результат:
397 days, 0:00:00

Если в качестве первого аргумента не указать ничего, то на место первой даты автоматически подставится текущая дата (полночь текущего дня, т.е. его начало). Если сегодня 2022-12-12, то с 2021-11-10 прошло ровно столько дней:

SELECT AGE(timestamp '2021-11-10')

Результат:
397 days, 0:00:00

На самом деле текущей дате соответствует значение current_date:

SELECT AGE(current_date, '2021-11-10')

Результат:
397 days, 0:00:00

Можете самостоятельно запустить два запроса — с current_date и без — и сравнить полученные результаты. В вашем случае это будут новые результаты, но они должны совпасть.

А само значение current_date можно вызвать так:

SELECT current_date

Результат:
12/12/22

И ещё один нюанс: чтобы результат отображался не в виде количества дней, а в более удобном формате, можно переводить результат вычислений в тип VARCHAR:

SELECT AGE(current_date, '2021-11-10')::VARCHAR

Результат:
1 year 1 mon 2 days
И напоследок кратко познакомимся с чуть более продвинутым функционалом — агрегатными выражениями с фильтрацией.

Если после агрегирующей функции указать ключевое слово FILTER и поместить в скобках некоторое условие [condition] после WHERE, то агрегирующей функции на вход будут поданы только те строки, для которых условие фильтра окажется истинным. В общем виде эта конструкция выглядит так:

SELECT agg_function(column) FILTER (WHERE [condition])
FROM table

Пример:

SELECT AVG(column_1) FILTER (WHERE column_2 > 100)
FROM table

Это очень похоже на обычную фильтрацию с агрегацией, которую мы рассматривали в предыдущих задачах, только в данном случае условие на отбор записей указывается сразу в блоке SELECT. Преимущество такой записи в том, что она позволяет проводить некоторые расчёты без необходимости писать отдельные запросы с блоком WHERE для получения промежуточных результатов.

Рассмотрим следующий пример.

В нашем случае довольно понятно, как посчитать общее количество пользователей, также вроде бы понятно, как посчитать количество пользователей, которые хотя бы раз отменяли заказ — достаточно просто указать нужное условие в операторе WHERE. Но как в рамках одного запроса посчитать тех, кто никогда не отменял свой заказ? Поскольку объединять несколько запросов вместе мы пока не умеем, на помощь нам может прийти агрегатное выражение.
Подведём итоги
В этом уроке мы:

Познакомились с ключевым словом DISTINCT.
Разобрались, как работают агрегирующие функции.
Узнали разницу между COUNT(\*) и COUNT(column).
Научились совмещать фильтрацию и агрегацию в одном запросе.
Поработали с массивами и узнали, что делает функция array_length.
Узнали ещё больше про даты и время и познакомились с функцией AGE.
Затронули более продвинутую тему — агрегатные выражения с фильтрацией.
